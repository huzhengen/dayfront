### ~^版本别搞混了

借助Node.js的帮助，前端开发进入到了一个自动化的时代，不可避免的会使用到npm，比如Vue.js的一个项目，首先得安装相关的依赖

```
npm install
```

但是经常会出现类似这样的问题，在做项目迁移的时候，某个包依赖突然就报错了，唯一的解释就是安装了该依赖的不同版本，然而`package.json`并没有修改，也就证明咱们在`dependencies`定义的依赖并不能确定唯一的版本号，而是为随着时间变化的。比如我们通过npm安装一个包

```
npm install moment --save
```

上面的代码会安装最新的moment版本，然后将类似下面的依赖关系加入到package.json文件中

```
{
	"moment": "^2.22.1"
}
```

然而上面的定义是无法保证我们在任何时候通过`npm install`重新安装依赖的时候moment版本都是`2.22.1`。

为什么会出现这样的情况呢？因为npm希望我们将依赖升级到新版本，注意并不一定是最新版本，而是通过一套规则来识别具体要安装的版本是哪一个。

依赖版本的命名方式为semver([major].[minor].[patch])，它是语义化版本（Semantic Versioning）规范的一个实现，实现了版本和版本范围的解析、计算、比较。指定的版本可以是具体的某个版本，也可以是某个范围的版本。

常见的两种格式就是以`^`和`~`开头的，比如通过一开始npm install安装的默认就是以`^`开头的，接下来我们就看看这两者之间的区别。

**^version**

更新到当前major version（也就是第一位数字）中最新的版本

>从左数，第1个不为0的数字+1，后面的变成0

示例

```
^1.2.3 := >=1.2.3 <2.0.0
^0.2.3 := >=0.2.3 <0.3.0
^0.0.3 := >=0.0.3 <0.0.4
^1.2.3-beta.2 := >=1.2.3-beta.2 <2.0.0
^0.0.3-beta := >=0.0.3-beta <0.0.4
```

比如我安装了下面的版本axios

```
{
	"axios": "^0.18.0",
}
```

**~version**

更新到当前minor version（也就是中间的那位数字）中最新的版本

>从左数，第2个数字+1，后面的变成0

```
~1.2.3 >=1.2.3 <1.(2+1).0 := >=1.2.3 <1.3.0
~1.2 := >=1.2.0 <1.(2+1).0 := >=1.2.0 <1.3.0(等价于1.2.x)
~0.2.3 := >=0.2.3 <0.(2+1).0 := >=0.2.3 <0.3.0
~0.2 := >=0.2.0 <0.(2+1).0 := >=0.2.0 <0.3.0(等价于0.2.x)
~1.2.3-beta.2 := >=1.2.3-beta.2 <1.3.0
```

特殊的

```
~1 := >=1.0.0 <(1+1).0.0 := >=1.0.0 <2.0.0(等价于1.x)
~0 := >=0.0.0 <(0+1).0.0 := >=0.0.0 <1.0.0(等价于0.x)
```

为了方便记忆，我们可以这样想，在正则表达式，放在首位的`^`表示匹配第一个，所以也就对应到这里的major，而波浪线`~`表示波动到第二位，也就是minor。

说了这么多，究竟该如何解决上面的问题呢？如何保证我每次安装的版本都一致，当然有同学会说，直接写死啊，去掉前面的`^`

```
{
	"moment": "2.22.1"
}
```

的确，这算是一种解决方案。但是这样一来我们就没办法安装最新的包了，还有另外一种方案就是，新版的npm提供了`package-lock.json`文件，会自动生成一个依赖树，在提升安装速度的同时也保证了每次安装的依赖包版本都是一样的。