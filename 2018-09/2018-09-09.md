### 数组解构你用了吗

作为ES6的新特性，解构赋值（Destructuring）可以简化我们的代码，以前只能一对一赋值，现在有了解构赋值就可以一次性给多个变量赋值了

当然被解构的可以是数组，也可以是对象，今天我们就来看看数组的解构。

讲解之前，我们先来看一道题：交换两个变量的值

```
let a = 1
let b = 2
```

常规的做法是定义一个新的变量`c`

```
let c = a
a = b
b = c
```

但是有了解构，我们可以这样做

```
[a, b] = [b, a]
```

是不是很酷？理解起来其实很简单，就是等号左右两边数组的每个对应位置的赋值，常见的用法是：

```
ket [a, b] = [1, 2]
```

如果右边有多余的，则被忽略

```
let [a, b] = [1, 2, 3]
```

上面的两个表达式的`a`为`1`，`b`为`2`。如果左边的元素比右边多，则多余的元素未被赋值，为`undefined`

```
let [a, b] = [1]
```

这里的`b`就成了`undefined`了。空元素也是会占位的：

```
let [a, b] = [1, 2, 3]
```

`a`为`1`，`b`为`3`。

**展开符**

```
let [a, ...b] = [1, 2, 3, 4]
```

这里`a`为`1`，`b`为`[2, 3, 4]`，那如果是这样呢？

```
let [a, ...b] = [1]
```

这里的`b`并不是`undefined`，而是一个空数组`[]`。

那么如果把展开符用在`a`上呢？

```
let [...a, b] = [1, 2, 3, 4]
```

上面的代码是会报错的

```
VM247:1 Uncaught SyntaxError: Rest element must be last element
```

意思是只能用在最后一个变量上。

**报错**

如果等号右边的不是数组或可迭代的结构，则会报错，比如下面的写法都会报错：

```
let [a] = 20
let [a] = null
let [a] = true
let [a] = undefined
let [a] = {}
```

注意字符串并不在上面的列表中，因为字符串是可迭代的。

```
let [a, b] = 'hello'
```

这里`a`为`h`，`b`为`e`

**默认值**

解构赋值允许设置默认值，如果右边对应位置没有匹配值，则取该值。比如

```
let [a, b=2] = [1]
```

这里`a`为`1`，`b`为`2`