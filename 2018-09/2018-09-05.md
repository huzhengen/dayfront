### 零延迟并非零延迟

相信有不少同学会在开发中遇到一类问题：代码的先后执行顺序有问题，于是就想到用`setTimeout`来延迟执行

```
setTiemout(function(){
...
}, 1000)
```

上面的代码表示在1秒后执行，但是为了让效果看上去更顺畅，我们得降低这个延迟时间，于是改成

```
setTiemout(function(){
...
}, 100)
```

就这样一直降低这个时间，最后我们惊讶地发现，知道这个值变成了`0`，也是没问题的

```
setTiemout(function(){
...
}, 0)
```

那么问题来了，既然你这表示在0秒之后执行，那还写个定时器干嘛呢？压根没有起到延时的效果啊。

接下来我们就一步一步地揭开这个谜底，先了解几个基本的概念：

**单线程**

基于浏览器的特殊性，JavaScript是单线程的，同一时间只能执行一个任务。但是虽然是单线程，也是能通过任务队列实现出异步效果的。

所以JS中的任务可以有两种：同步任务和异步任务

**同步任务**

在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。

**异步任务**

一开始不进入主线程，而是进入`任务队列`的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。

**定时器**

除了异步任务，定时器（`setTimeout()`和`setInterval()`）也会被放入任务队列，同样遵循上面的异步任务处理方式

>所以不管`setTimeout(fn, delay)`中的`delay`是多少，该定时器都不会立即执行，都会被塞到任务队列中去，等到同步任务完成了再进入主线程执行。

下面我们来看一个简单的例子

```
setTimeout(function(){
    console.log('start')
}, 0)
for(let i=0; i<=100; i++){
    console.log(i)
}
```

上面的运行结果并非是先打印`start`，而是等打印完所有`i`之后才打印了`start`。

可以看到，并没有办法保证回调函数一定会在`setTimeout()`指定的延迟时间后精确执行。