# 坑坑洼洼的数学运算

JavaScript 中的数学计算一直以来都是布满了坑，比如随口就能说出 `0.1 + 0.2 !== 0.3`，作为前端开发者，我们应该知道如何避开这些坑。今天我们就来看几个大家也许不知道的暗坑。

### max() vs min()

```js
Math.max() > Math.min()
// false

Math.max() < Math.min()
// true
```

是的，你没看错，`Math.max()` 要比 `Math.min()` 小。为什么呢？`Math.max()` 用来返回一组数字中的最大值，而如果不传参数，则返回 `-Infinity`（负无穷大）

```js
Math.max(5, 3, 8) // 8
Math.max() // -Infinity
```

那有同学要问了，为什么不传参数时 `Math.max()` 要返回 `-Infinity` 而不是其它值呢？其实很好理解，`Math.max()` 是要获取传入的参数中最大的一个，既然是要拿到最大值，那必然默认的就会是一个最小值，否则不就取到这个默认值了吗？可能其中的过程如下

```js
max () {
  let _max = -Infinity
  for (let val of arguments) {
    if (val > _max) {
      _max = val
    }
  }
  return _max
}
```

而与之相反，`Math.min()` 如果不传参数，则返回 `Infinity`（正无穷大）

```js
Math.min() // Infinity
```

因为 `Infinity > -Infinity` 所以便有了 `Math.min() > Math.max()`

### 1 < 2 < 3

```js
1 < 2 < 3   // true
3 > 2 > 1   // false
```

**因为 JavaScript 解析器是从左到右执行的**，所以 `1 < 2 < 3` 中会先执行 `1 < 2` 结果为 `true`，然后再比较 `true < 3`，等价于 `Number(true) < 3`

```js
Number(true) // 1
Number(true) < 3 // true
```

同样的思路，`3 > 2 > 1` 最终会变成 `Number(true) > 1` 很明显是不对的

```js
Number(true) // 1
Number(true) > 1 // false
```

### '5' + 3

```js
'5' + 3  // '53'
'5' - 3  // 2
```

之所以加法减法表现不一样，本质上是因为 `-` 只会用在数字运算中，而 `+` 则还可以用在字符串拼接中。

所以遇到 `-` 会毫不犹豫将非数字转为数字，而遇到 `+` 时，如果两边的类型不是数字或字符串的时候，会进行一定的类型转换，优先考虑转换为字符串并连接。

### [] + {}

```js
[] + {} // '[object Object]'
{} + [] // 0
```

接着上面的例子，`+` 在 `[] + {}` 中会进行类型转换，分别调用 `toString()` 方法

```js
([]).toString() // ''
({}).toString() // "[object Object]"
```

于是最终结果就有了这个的结果。那为什么 `{} + []` 结果却为 `0` 呢？仅仅是交换了两个对象的位置而已啊。这是因为此处以 `{}` 开头被被认为是一个语句块，空表示什么都不做，于是就被忽略了，最终也就变成了一个一元表达式 `+[]`。

前面我们讲过，一元正号运算符位于其操作数前面，计算其操作数的数值，如果操作数不是一个数值，会尝试将其转换成一个数值。所以 `+[]` 就等价于 `Number([])` 结果为 `0`。

所以问题的本质还是在于 `{}` 不同于 `[]` 有其它层面的用途，那么如何让 `{}` 就被当成是一个对象字面量呢？很简单，加个括号即可

```js
({}) + [] // "[object Object]"
```